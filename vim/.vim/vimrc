set autoread
set backspace=indent,eol,start
set clipboard=unnamed,unnamedplus
set fillchars=vert:\ "
set hidden
set lazyredraw
set modeline
set mouse=
set noshowmode
set path+=**
set viminfo=""

set statusline=
set statusline+=\ %m%r
set statusline+=%f\ "
set statusline+=%1*
set statusline+=%*
set statusline+=%=
set statusline+=%1*
set statusline+=\ %l:%c/%L\ %p%%\ "
set statusline+=%*

set noerrorbells
set novisualbell

set splitbelow
set splitright

set complete=
set complete+=.
set complete+=b
set complete+=t
set completeopt=
set completeopt+=menu
set completeopt+=longest

set gdefault
set hlsearch
set incsearch
set iskeyword+=-
set magic

set foldmethod=marker
set nofoldenable

set shortmess=
set shortmess+=I
set shortmess+=T
set shortmess+=a
set shortmess+=c
set shortmess+=t

set nolist
set nowrap
set scrolloff=10
set sidescrolloff=10

set number
set relativenumber

set wildignorecase
set wildmenu
set wildignore=

set nobackup
set noswapfile
set noundofile
set nowritebackup

set smartcase
set ignorecase

set autoindent
set breakindent
set smartindent

set expandtab
set shiftround
set shiftwidth=4
set smarttab
set softtabstop=4
set tabstop=4

try
    set encoding=utf-8
    scriptencoding utf-8
catch
endtry

if has('autocmd')
    filetype on
    filetype plugin on
    filetype indent on
endif

if has('syntax')
    syntax enable
endif

let mapleader = ' '

nnoremap <Expr> j           v:count ? 'j' : 'gj'
nnoremap <Expr> k           v:count ? 'k' : 'gk'

nnoremap        J           gt
nnoremap        K           gT

nnoremap        <C-a>       ^h
vnoremap        <C-a>       ^h
nnoremap        H           ^h
vnoremap        H           ^h

nnoremap        <C-e>       $
vnoremap        <C-e>       $
nnoremap        L           $
vnoremap        L           $

nnoremap        N           Nzzzv
nnoremap        n           nzzzv

vnoremap        <           <gv
vnoremap        >           >gv

nnoremap        ]b          :<C-u>bnext<CR>
nnoremap        [b          :<C-u>bprevious<CR>

nnoremap        <A-h>       <C-w>h
nnoremap        <A-j>       <C-w>j
nnoremap        <A-k>       <C-w>k
nnoremap        <A-l>       <C-w>l

nnoremap        <C-l>       :<C-u>nohlsearch<Bar>redraw!<Bar>echo<CR><C-l>

cnoremap        ;/          <C-r>=expand('%:p:h').'/'<CR>
cnoremap        ;;          <C-r>=expand('%:t')<CR>
cnoremap        ;.          <C-r>=expand('%:p:r')<CR>

cnoremap        <C-a>       <Home>
cnoremap        <C-e>       <End>

nnoremap        gw          vapgw

nnoremap        Q           @q

nnoremap        <Leader>c   ^v$h
nnoremap        <Leader>v   ggVG

map             <Leader>sn  ]s
map             <Leader>sp  [s
map             <Leader>sa  zg
map             <Leader>s?  z=

inoremap        <C-v>       <C-c>"+pi
cnoremap        <C-v>       <C-r>+

nmap            <Leader>w   :<C-u>w!<CR>
nmap            <Leader>wq  :<C-u>wq!<CR>

nnoremap        ZX          :<C-u>qa!<CR>

function! SwitchCase()
    normal! ~
    if strlen(getline('.')) != virtcol('.')
        normal! h
    endif
endfunction
nnoremap        ~           :<C-u>call SwitchCase()<CR>

function! MapGoToTab()
    let s:i = 1
    while s:i < 10
        exe 'nnoremap <Leader>' . s:i . ' :<C-u>tabnext ' . s:i . '<CR>'
        let s:i += 1
    endwhile
endfunction
call MapGoToTab()

if executable('doas')
    command! W :execute ':silent w !doas tee % >/dev/null' | :edit!
elseif executable('sudo')
    command! W :execute ':silent w !sudo tee % >/dev/null' | :edit!
endif

autocmd BufEnter * set noreadonly

if empty(glob('~/.vim/autoload/plug.vim'))
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
                \ 'https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'

    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

call plug#begin('~/.vim/.plug')

" {{{
Plug 'vim-utils/vim-husk'
" }}}

" {{{
Plug 'bronson/vim-visual-star-search'
" }}}

" {{{
Plug 'google/vim-searchindex'
" }}}

" {{{
Plug 'farmergreg/vim-lastplace'
" }}}

" {{{
Plug 'jiangmiao/auto-pairs'
" }}}

" {{{
Plug 'romainl/vim-cool'
" }}}

" {{{
Plug 'justinmk/vim-sneak'
let g:sneak#label = 1

nmap f <Plug>Sneak_f
nmap F <Plug>Sneak_F
vmap f <Plug>Sneak_f
vmap F <Plug>Sneak_F

nmap t <Plug>Sneak_t
nmap T <Plug>Sneak_T
vmap t <Plug>Sneak_t
vmap T <Plug>Sneak_T

nmap <Plug>(Go_away_Sneak_s) <Plug>Sneak_s
nmap <Plug>(Go_away_Sneak_S) <Plug>Sneak_S
" }}}

" {{{
Plug 'tpope/vim-repeat'
" }}}

" {{{
Plug 'tpope/vim-surround'
" }}}

" {{{
Plug 'tpope/vim-sleuth'
" }}}

" {{{
Plug 'tpope/vim-unimpaired'
" }}}

" {{{
Plug 'tpope/vim-eunuch'
" }}}

" {{{
Plug 'tpope/vim-commentary'
" }}}

" {{{
Plug 'tpope/vim-fugitive'
" }}}

" {{{
Plug 'tpope/vim-rhubarb'
" }}}

" {{{
Plug 'tpope/vim-abolish'
" }}}

" {{{
Plug 'tpope/vim-obsession'
" }}}

" {{{
Plug 'tpope/vim-speeddating'
" }}}

" {{{
Plug 'RRethy/vim-illuminate'
" }}}

" {{{
Plug 'terryma/vim-expand-region'
" }}}

" {{{
Plug 'ervandew/supertab'

let g:SuperTabDefaultCompletionType = '<C-n>'
" }}}

" {{{
Plug 'chrisbra/Colorizer'
" }}}

" {{{
Plug 'junegunn/rainbow_parentheses.vim'
" }}}

" {{{
if executable('gpg')
    Plug 'jamessan/vim-gnupg'
endif
" }}}

" {{{
if executable('tmux')
    Plug 'tmux-plugins/vim-tmux', { 'for': 'tmux' }
    Plug 'tmux-plugins/vim-tmux-focus-events'
endif
" }}}

" {{{
if executable('ack') || executable('ag')
    Plug 'mileszs/ack.vim'
    if executable('ag')
        let g:ackprg = 'ag --vimgrep'
    endif
endif
" }}}

" {{{
if executable('wakatime')
    Plug 'wakatime/vim-wakatime'
endif
" }}}

" {{{
Plug 'editorconfig/editorconfig-vim'
" }}}

" {{{
Plug 'vim-scripts/SyntaxRange'
" }}}

" {{{
Plug 'gentoo/gentoo-syntax'
" }}}

" {{{
Plug 'elzr/vim-json', {'for': 'json'}
let g:vim_json_syntax_conceal = 0
" }}}

" {{{
Plug 'chr4/nginx.vim', {'for': 'nginx'}
" }}}

call plug#end()
