if ! has('nvim')
    set nocompatible
endif

set autoread
set backspace=indent,eol,start
set clipboard=unnamed,unnamedplus
set fillchars=vert:\ "
set hidden
set lazyredraw
set modeline
set mouse=
set noshowmode
set path+=**

set statusline=
set statusline+=\ %m%r
set statusline+=%f\ "
set statusline+=%1*
set statusline+=%*
set statusline+=%=
set statusline+=%1*
set statusline+=\ %l:%c/%L\ %p%%\ "
set statusline+=%*

set noerrorbells
set novisualbell

set splitbelow
set splitright

set complete=
set complete+=.
set complete+=b
set complete+=t
set completeopt=
set completeopt+=menu
set completeopt+=longest

set gdefault
set hlsearch
set incsearch
set iskeyword+=-
set magic

set foldmethod=marker
set nofoldenable

set shortmess=
set shortmess+=I
set shortmess+=T
set shortmess+=a
set shortmess+=c
set shortmess+=t

set nolist
set nowrap
set scrolloff=10
set sidescrolloff=10

set number
set relativenumber

set wildignorecase
set wildmenu
set wildignore=

set nobackup
set noswapfile
set noundofile
set nowritebackup

set smartcase
set ignorecase

set autoindent
set breakindent
set smartindent

set expandtab
set shiftround
set shiftwidth=4
set smarttab
set softtabstop=4
set tabstop=4

try
    set encoding=utf-8
    scriptencoding utf-8
catch
endtry

if has('autocmd')
    filetype on
    filetype plugin on
    filetype indent on
endif

if has('syntax')
    syntax enable
endif

let mapleader = ' '

nnoremap <Expr> j           v:count ? 'j' : 'gj'
nnoremap <Expr> k           v:count ? 'k' : 'gk'

nnoremap        J           gt
nnoremap        K           gT

nnoremap        <C-a>       ^h
vnoremap        <C-a>       ^h
nnoremap        H           ^h
vnoremap        H           ^h

nnoremap        <C-e>       $
vnoremap        <C-e>       $
nnoremap        L           $
vnoremap        L           $

nnoremap        N           Nzzzv
nnoremap        n           nzzzv

vnoremap        <           <gv
vnoremap        >           >gv

nnoremap        ]b          :<C-u>bnext<CR>
nnoremap        [b          :<C-u>bprevious<CR>

nnoremap        <A-h>       <C-w>h
nnoremap        <A-j>       <C-w>j
nnoremap        <A-k>       <C-w>k
nnoremap        <A-l>       <C-w>l

nnoremap        <C-l>       :<C-u>nohlsearch<Bar>redraw!<Bar>echo<CR><C-l>

cnoremap        ;/          <C-r>=expand('%:p:h').'/'<CR>
cnoremap        ;;          <C-r>=expand('%:t')<CR>
cnoremap        ;.          <C-r>=expand('%:p:r')<CR>

cnoremap        <C-a>       <Home>
cnoremap        <C-e>       <End>

nnoremap        gw          vapgw

nnoremap        Q           @q

nnoremap        <Leader>c   ^v$h
nnoremap        <Leader>v   ggVG

map             <Leader>sn  ]s
map             <Leader>sp  [s
map             <Leader>sa  zg
map             <Leader>s?  z=

inoremap        <C-v>       <C-c>"+pi
cnoremap        <C-v>       <C-r>+

nmap            <Leader>w   :<C-u>w!<CR>
nmap            <Leader>wq  :<C-u>wq!<CR>

nnoremap        ZX          :<C-u>qa!<CR>

function! SwitchCase()
    normal! ~
    if strlen(getline('.')) != virtcol('.')
        normal! h
    endif
endfunction
nnoremap        ~           :<C-u>call SwitchCase()<CR>

function! MapGoToTab()
    let s:i = 1
    while s:i < 10
        exe 'nnoremap <Leader>' . s:i . ' :<C-u>tabnext ' . s:i . '<CR>'
        let s:i += 1
    endwhile
endfunction
call MapGoToTab()

if executable('doas')
    command! W :execute ':silent w !doas tee % >/dev/null' | :edit!
elseif executable('sudo')
    command! W :execute ':silent w !sudo tee % >/dev/null' | :edit!
endif

autocmd BufEnter * set noreadonly

if empty(glob('~/.vim/autoload/plug.vim'))
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
                \ 'https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'

    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

call plug#begin('~/.vim/.plug')

" {{{
Plug 'vim-utils/vim-husk'
" }}}

" {{{
Plug 'bronson/vim-visual-star-search'
" }}}

" {{{
Plug 'google/vim-searchindex'
" }}}

" {{{
Plug 'farmergreg/vim-lastplace'
" }}}

" {{{
Plug 'jiangmiao/auto-pairs'
" }}}

" {{{
Plug 'romainl/vim-cool'
" }}}

" {{{
Plug 'justinmk/vim-sneak'
let g:sneak#label = 1

nmap f <Plug>Sneak_f
nmap F <Plug>Sneak_F
vmap f <Plug>Sneak_f
vmap F <Plug>Sneak_F

nmap t <Plug>Sneak_t
nmap T <Plug>Sneak_T
vmap t <Plug>Sneak_t
vmap T <Plug>Sneak_T

nmap <Plug>(Go_away_Sneak_s) <Plug>Sneak_s
nmap <Plug>(Go_away_Sneak_S) <Plug>Sneak_S
" }}}

" {{{
Plug 'tpope/vim-repeat'
" }}}

" {{{
Plug 'tpope/vim-surround'
" }}}

" {{{
Plug 'tpope/vim-sleuth'
" }}}

" {{{
Plug 'tpope/vim-unimpaired'
" }}}

" {{{
Plug 'tpope/vim-eunuch'
" }}}

" {{{
Plug 'tpope/vim-commentary'
" }}}

" {{{
Plug 'tpope/vim-fugitive'
" }}}

" {{{
Plug 'tpope/vim-rhubarb'
" }}}

" {{{
Plug 'tpope/vim-abolish'
" }}}

" {{{
Plug 'tpope/vim-obsession'
" }}}

" {{{
Plug 'tpope/vim-speeddating'
" }}}

" {{{
Plug 'RRethy/vim-illuminate'
" }}}

" {{{
Plug 'terryma/vim-expand-region'
" }}}

" {{{
Plug 'ervandew/supertab'

let g:SuperTabDefaultCompletionType = '<C-n>'
" }}}

" {{{
Plug 'chrisbra/Colorizer'
" }}}

" {{{
Plug 'junegunn/rainbow_parentheses.vim'
" }}}

" {{{
if executable('gpg')
    Plug 'jamessan/vim-gnupg'
endif
" }}}

" {{{
if executable('tmux')
    Plug 'tmux-plugins/vim-tmux', { 'for': 'tmux' }
    Plug 'tmux-plugins/vim-tmux-focus-events'
endif
" }}}

" {{{
if executable('ack') || executable('ag')
    Plug 'mileszs/ack.vim'
    if executable('ag')
        let g:ackprg = 'ag --vimgrep'
    endif
endif
" }}}

" {{{
if executable('wakatime')
    Plug 'wakatime/vim-wakatime'
endif
" }}}

" {{{
Plug 'editorconfig/editorconfig-vim'
" }}}

" {{{
Plug 'mattn/calendar-vim'
" }}}

" {{{
Plug 'vim-scripts/SyntaxRange'
" }}}

" {{{
Plug 'jceb/vim-orgmode', { 'for': 'org' }
let g:org_agenda_files = [ '~/org/*.org' ]
" }}}

" {{{
Plug 'gentoo/gentoo-syntax'
" }}}

" {{{
Plug 'elzr/vim-json', {'for': 'json'}
let g:vim_json_syntax_conceal = 0
" }}}

" {{{
Plug 'chr4/nginx.vim', {'for': 'nginx'}
" }}}

" {{{
if has('nvim') && has('python3')
    " {{{
    Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
    let g:deoplete#enable_at_startup = 1
    " }}}

    " {{{
    Plug 'autozimu/LanguageClient-neovim', { 'branch': 'next', 'do': './install.sh' }
    let g:LanguageClient_loadSettings = 1

    nnoremap <Leader>lm :<C-u>call LanguageClient_contextMenu()<CR>
    nnoremap <Leader>la :<C-u>call LanguageClient_workspace_applyEdit()<CR>
    nnoremap <Leader>lc :<C-u>call LanguageClient#textDocument_completion()<CR>
    nnoremap <Leader>ld :<C-u>call LanguageClient#textDocument_definition()<CR>
    nnoremap <Leader>le :<C-u>call LanguageClient#textDocument_references()<CR>
    nnoremap <Leader>lf :<C-u>call LanguageClient#textDocument_formatting()<CR>
    nnoremap <Leader>lh :<C-u>call LanguageClient#textDocument_hover()<CR>
    nnoremap <Leader>lr :<C-u>call LanguageClient#textDocument_rename()<CR>
    nnoremap <Leader>ls :<C-u>call LanguageClient#textDocument_documentSymbol()<CR>
    nnoremap <Leader>lt :<C-u>call LanguageClient#textDocument_typeDefinition()<CR>

    let g:LanguageClient_serverCommands = {}

    if executable('ccls')
        let g:LanguageClient_serverCommands[ 'c'   ] = [ 'ccls' ]
        let g:LanguageClient_serverCommands[ 'cpp' ] = [ 'ccls' ]

        nnoremap <Leader>h :<C-u>call LanguageClient#findLocations({'method':'$ccls/navigate','direction':'L'})<CR>
        nnoremap <Leader>j :<C-u>call LanguageClient#findLocations({'method':'$ccls/navigate','direction':'D'})<CR>
        nnoremap <Leader>k :<C-u>call LanguageClient#findLocations({'method':'$ccls/navigate','direction':'U'})<CR>
        nnoremap <Leader>l :<C-u>call LanguageClient#findLocations({'method':'$ccls/navigate','direction':'R'})<CR>
    elseif executable('clangd')
        let g:LanguageClient_serverCommands[ 'c'   ] = [ 'clangd', '-background-index' ]
        let g:LanguageClient_serverCommands[ 'cpp' ] = [ 'clangd', '-background-index' ]
    endif

    if executable('gopls')
        let g:LanguageClient_serverCommands[ 'go' ] = [ 'gopls' ]
    endif

    if executable('haskell-language-server-wrapper')
        let g:LanguageClient_serverCommands[ 'haskell' ] = [ 'haskell-language-server-wrapper', '--lsp' ]
    endif

    if executable('pyls')
        let g:LanguageClient_serverCommands[ 'python' ] = [ 'pyls' ]
    endif
    " }}}

    " {{{
    Plug 'Shougo/neco-syntax'
    " }}}

    " {{{
    Plug 'Shougo/neco-vim', { 'for': 'vim' }
    " }}}

    " {{{
    Plug 'Shougo/neoinclude.vim', { 'for': [ 'c', 'cpp' ] }
    " }}}

    " {{{
    Plug 'deoplete-plugins/deoplete-zsh', { 'for': 'zsh' }
    " }}}

    " {{{
    Plug 'deoplete-plugins/deoplete-docker', { 'for': 'Dockerfile' }
    " }}}

    " {{{
    Plug 'Shougo/echodoc.vim'

    let g:echodoc#enable_at_startup = 1
    let g:echodoc#type = 'signature'
    " }}}

    " {{{
    Plug 'sheerun/vim-polyglot'
    " }}}

    " {{{
    if executable('clang-format')
        Plug 'rhysd/vim-clang-format', { 'for': [ 'c', 'cpp' ] }

        nnoremap <Buffer><Leader>cf :<C-u>ClangFormat<CR>
        vnoremap <Buffer><Leader>cf :<C-u>ClangFormat<CR>
    endif
    " }}}

    " {{{
    Plug 'hynek/vim-python-pep8-indent', { 'for': 'python' }
    " }}}
endif

call plug#end()
